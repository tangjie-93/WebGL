<!DOCTYPE >
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <title>绘制矩形-顶点索引</title>
    <!-- 顶点着色器源码 -->
    <script id="vertexShader" type="x-shader/x-vertex">
      //attribute声明vec3类型变量apos
      attribute vec3 apos;
      void main() {
        //顶点坐标apos赋值给内置变量gl_Position
        //逐顶点处理数据
        gl_Position = vec4(apos,1.0);
      }
    </script>
    <!-- 片元着色器源码 -->
    <script id="fragmentShader" type="x-shader/x-fragment">

      void main() {
        // 逐片元处理数据，所有片元(像素)设置为红色
        gl_FragColor = vec4(1.0,0.0,0.0,1.0);
      }
    </script>
    <script>
      function init() {
        let canvas = document.querySelector("#canvas");
        let gl = canvas.getContext("webgl2");
        gl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
        //顶点着色器源码
        var vertexShaderSource = document.getElementById("vertexShader")
          .innerText;

        //片元着色器源码
        var fragShaderSource = document.getElementById("fragmentShader")
          .innerText;
        //初始化着色器
        var program = initShader(gl, vertexShaderSource, fragShaderSource);
        render(program, gl);
      }
      function render(program, gl) {
        const position =new Float32Array([
          -0.5,0.5,0.0,
          0.5,0.5,0.0,
          0.5,-0.5,0.0,
          -0.5,-0.5,0.0
        ]);
        const indexes = new Uint8Array([0, 1, 2, 0, 2, 3]);
        //创建顶点缓冲区对象
        let vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER,position,gl.STATIC_DRAW);

        //创建索引缓冲区对象
        var indexesBuffer = gl.createBuffer();
        //绑定缓冲区对象
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexesBuffer);
        //索引数组indexes数据传入缓冲区
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexes, gl.STATIC_DRAW);

        
        var aposLocation = gl.getAttribLocation(program, "apos");
        gl.enableVertexAttribArray(aposLocation);
        gl.vertexAttribPointer(aposLocation, 3, gl.FLOAT, false, 0, 0);

        
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
      }
      //声明初始化着色器函数
      function initShader(gl, vertexShaderSource, fragmentShaderSource) {
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);

        let tmpLog = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);
        if (!tmpLog && !gl.isContextLost()) {
          alert(tmpLog);
          return;
        }
        tmpLog = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);
        if (!tmpLog && !gl.isContextLost()) {
          alert(tmpLog);
          return;
        }

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!tmpLog && !gl.isContextLost()) {
          alert(tmpLog);
          return;
        }
        gl.useProgram(program);
        return program;
      }
    </script>
  </head>
  <body onload="init()">
    <canvas height="400" width="400" id="canvas"> 不支持canvas </canvas>
  </body>
</html>
