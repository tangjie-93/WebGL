<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
        @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");

        body {
            margin: 0;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <!-- vertex shader -->
    <script id="vertex-shader-3d" type="x-shader/x-vertex">
      attribute vec4 a_position;
      uniform mat4 u_matrix;
      varying vec3 v_normal;
      void main() {
        // Multiply the position by the matrix.
        gl_Position = u_matrix * a_position;
        // Pass a normal. Since the positions
        // centered around the origin we can just
        // pass the position
        v_normal = normalize(a_position.xyz);
      }
    </script>
    <!-- fragment shader -->
    <script id="fragment-shader-3d" type="x-shader/x-fragment">
      precision mediump float;
      // Passed in from the vertex shader.
      varying vec3 v_normal;
      // The texture.
      uniform samplerCube u_texture;
      void main() {
         gl_FragColor = textureCube(u_texture, normalize(v_normal));
      }
    </script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
</body>

</html>
<script>
    function main() {
        // Get A WebGL context
        /** @type {HTMLCanvasElement} */
        var canvas = document.querySelector("#canvas");
        var gl = canvas.getContext("webgl");
        if (!gl) {
            return;
        }
        // setup GLSL program
        var program = webglUtils.createProgramFromScripts(gl, [
            "vertex-shader-3d",
            "fragment-shader-3d",
        ]);

        // look up where the vertex data needs to go.
        var positionLocation = gl.getAttribLocation(program, "a_position");

        // lookup uniforms
        var matrixLocation = gl.getUniformLocation(program, "u_matrix");
        var textureLocation = gl.getUniformLocation(program, "u_texture");

        // Create a buffer for positions
        var positionBuffer = gl.createBuffer();
        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // Put the positions in the buffer
        setGeometry(gl);

        // // 生成纹理
        // var texture = gl.createTexture();
        // gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);

        // // Get A 2D context 获取2维上下文
        // /** @type {Canvas2DRenderingContext} */
        // const ctx = document.createElement("canvas").getContext("2d");
        // //立方体纹理需要正方形纹理
        // ctx.canvas.width = 128;
        // ctx.canvas.height = 128;



        // const faceInfos = [
        //     {
        //         target: gl.TEXTURE_CUBE_MAP_POSITIVE_X,
        //         faceColor: "#F00",
        //         textColor: "#0FF",
        //         text: "+X",
        //     },
        //     {
        //         target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
        //         faceColor: "#FF0",
        //         textColor: "#00F",
        //         text: "-X",
        //     },
        //     {
        //         target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
        //         faceColor: "#0F0",
        //         textColor: "#F0F",
        //         text: "+Y",
        //     },
        //     {
        //         target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
        //         faceColor: "#0FF",
        //         textColor: "#F00",
        //         text: "-Y",
        //     },
        //     {
        //         target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
        //         faceColor: "#00F",
        //         textColor: "#FF0",
        //         text: "+Z",
        //     },
        //     {
        //         target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
        //         faceColor: "#F0F",
        //         textColor: "#0F0",
        //         text: "-Z",
        //     },
        // ];
        // faceInfos.forEach((faceInfo) => {
        //     const { target, faceColor, textColor, text } = faceInfo;
        //     generateFace(ctx, faceColor, textColor, text);

        //     // 上传画布到立方体贴图的每个面。
        //     const level = 0;
        //     const internalFormat = gl.RGBA;
        //     const format = gl.RGBA;
        //     const type = gl.UNSIGNED_BYTE;
        //     //用 gl.TEXTURE_CUBE_MAP 代替 gl.TEXTURE_2D,告诉WebGL生成一个立方体纹理而不是二维纹理
        //     // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        //     gl.texImage2D(target, level, internalFormat, format, type, ctx.canvas);
        // });
        // gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        // gl.texParameteri(
        //     gl.TEXTURE_CUBE_MAP,
        //     gl.TEXTURE_MIN_FILTER,
        //     gl.LINEAR_MIPMAP_LINEAR
        // );
        initTexture(gl);

        function initTexture(gl) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
            const faceInfos = [
                {
                    target: gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                    url:'../images/1.jpg' ,//'https://webglfundamentals.org/webgl/resources/images/computer-history-museum/pos-x.jpg',
                },
                {
                    target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                    url: '../images/2.jpg',//'https://webglfundamentals.org/webgl/resources/images/computer-history-museum/neg-x.jpg',
                },
                {
                    target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                    url:'../images/3.jpg' //'https://webglfundamentals.org/webgl/resources/images/computer-history-museum/pos-y.jpg',
                },
                {
                    target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                    url: '../images/4.jpg'//'https://webglfundamentals.org/webgl/resources/images/computer-history-museum/neg-y.jpg',
                },
                {
                    target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                    url: '../images/5.jpg'//'https://webglfundamentals.org/webgl/resources/images/computer-history-museum/pos-z.jpg',
                },
                {
                    target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                    url: '../images/6.jpg'//'https://webglfundamentals.org/webgl/resources/images/computer-history-museum/neg-z.jpg',
                },
            ];
            const promiseList = []
            faceInfos.forEach((faceInfo) => {
                const { target, url } = faceInfo;
                // Upload the canvas to the cubemap face.
                const level = 0;
                const internalFormat = gl.RGBA;
                const width = 512;
                const height = 512;
                const format = gl.RGBA;
                const type = gl.UNSIGNED_BYTE;
                // setup each face so it's immediately renderable
                gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);

                // Asynchronously load an image
                const promise = new Promise(resolve => {
                    const image = new Image();
                    image.crossOrigin = 'anonymous';
                    image.src = url;
                    image.addEventListener('load', function () {
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); //纹理图片上下反转,使得图片的左下角与UV坐标原点重合。
                        // Now that the image has loaded make copy it to the texture.
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                        gl.texImage2D(target, level, internalFormat, format, type, image);
                        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
                        resolve();
                    });
                })
                promiseList.push(promise)

            });
            Promise.all(promiseList).then(() => {
                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                // lookup uniforms
                // const skyboxLocation = gl.getUniformLocation(program, "u_skybox");
                // Tell the shader to use texture unit 0 for u_skybox
                gl.uniform1i(textureLocation, 0);
                requestAnimationFrame(drawScene);
            })

        }

        function radToDeg(r) {
            return (r * 180) / Math.PI;
        }

        function degToRad(d) {
            return (d * Math.PI) / 180;
        }

        var fieldOfViewRadians = degToRad(60);
        var modelXRotationRadians = degToRad(-20);
        var modelYRotationRadians = degToRad(-30);

        // Get the starting time.
        var then = 0;

        // requestAnimationFrame(drawScene);

        // Draw the scene.
        //渲染视图
        function drawScene(time) {
            // convert to seconds
            time *= 0.001;
            // Subtract the previous time from the current time
            var deltaTime = time - then;
            // Remember the current time for the next frame.
            then = time;

            webglUtils.resizeCanvasToDisplaySize(gl.canvas);

            // Tell WebGL how to convert from clip space to pixels
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            //只能看的到背面的
            gl.enable(gl.CULL_FACE);
            //开启深度测试
            gl.enable(gl.DEPTH_TEST);

            // Animate the rotation
            modelYRotationRadians += -0.7 * deltaTime;
            modelXRotationRadians += -0.4 * deltaTime;
            //清空画布或者深度缓冲区
            // Clear the canvas AND the depth buffer.
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Tell it to use our program (pair of shaders)
            gl.useProgram(program);

            // Turn on the position attribute
            gl.enableVertexAttribArray(positionLocation);

            // Bind the position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
            var size = 3; // 3 components per iteration
            var type = gl.FLOAT; // the data is 32bit floats
            var normalize = false; // don't normalize the data
            var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
            var offset = 0; // start at the beginning of the buffer
            //赋值
            gl.vertexAttribPointer(
                positionLocation,
                size,
                type,
                normalize,
                stride,
                offset
            );

            // 计算投影矩阵
            var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            var projectionMatrix = m4.perspective(
                fieldOfViewRadians,
                aspect,
                1,
                2000
            );

            var cameraPosition = [0, 0, 2];
            var up = [0, -1, 0];
            var target = [0, 0, 0];

            // Compute the camera's matrix using look at.
            //创建相机矩阵
            var cameraMatrix = m4.lookAt(cameraPosition, target, up);

            // Make a view matrix from the camera matrix.
            //根据相机矩阵创建视图矩阵
            var viewMatrix = m4.inverse(cameraMatrix);
            //视图投影矩阵
            var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

            var matrix = m4.xRotate(viewProjectionMatrix, modelXRotationRadians);
            matrix = m4.yRotate(matrix, modelYRotationRadians);

            // Set the matrix.
            gl.uniformMatrix4fv(matrixLocation, false, matrix);

            // Tell the shader to use texture unit 0 for u_texture
            // gl.uniform1i(textureLocation, 0);

            // Draw the geometry.
            gl.drawArrays(gl.TRIANGLES, 0, 6 * 6);

            // requestAnimationFrame(drawScene);
        }
    }

    function generateFace(ctx, faceColor, textColor, text) {
        const { width, height } = ctx.canvas;
        ctx.fillStyle = faceColor;
        ctx.fillRect(0, 0, width, height);
        ctx.font = `${width * 0.7}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = textColor;
        ctx.fillText(text, width / 2, height / 2);
    }

    // Fill the buffer with the values that define a cube.
    //构建立方体需要的数据
    function setGeometry(gl) {
        var positions = new Float32Array([
            -0.5,
            -0.5,
            -0.5,
            -0.5,
            0.5,
            -0.5,
            0.5,
            -0.5,
            -0.5,
            -0.5,
            0.5,
            -0.5,
            0.5,
            0.5,
            -0.5,
            0.5,
            -0.5,
            -0.5,

            -0.5,
            -0.5,
            0.5,
            0.5,
            -0.5,
            0.5,
            -0.5,
            0.5,
            0.5,
            -0.5,
            0.5,
            0.5,
            0.5,
            -0.5,
            0.5,
            0.5,
            0.5,
            0.5,

            -0.5,
            0.5,
            -0.5,
            -0.5,
            0.5,
            0.5,
            0.5,
            0.5,
            -0.5,
            -0.5,
            0.5,
            0.5,
            0.5,
            0.5,
            0.5,
            0.5,
            0.5,
            -0.5,

            -0.5,
            -0.5,
            -0.5,
            0.5,
            -0.5,
            -0.5,
            -0.5,
            -0.5,
            0.5,
            -0.5,
            -0.5,
            0.5,
            0.5,
            -0.5,
            -0.5,
            0.5,
            -0.5,
            0.5,

            -0.5,
            -0.5,
            -0.5,
            -0.5,
            -0.5,
            0.5,
            -0.5,
            0.5,
            -0.5,
            -0.5,
            -0.5,
            0.5,
            -0.5,
            0.5,
            0.5,
            -0.5,
            0.5,
            -0.5,

            0.5,
            -0.5,
            -0.5,
            0.5,
            0.5,
            -0.5,
            0.5,
            -0.5,
            0.5,
            0.5,
            -0.5,
            0.5,
            0.5,
            0.5,
            -0.5,
            0.5,
            0.5,
            0.5,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    }

    main();
</script>